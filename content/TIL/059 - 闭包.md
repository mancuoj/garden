---
date: 2024-02-28
tags:
  - til
  - js
---

当我们谈论闭包和它如何工作时，实际上我们是在讨论函数和它们的执行环境之间的关系，以及这些函数如何能够记住并访问它们被创建时的作用域中的变量，即使它们被在一个全然不同的作用域中调用。

```js
var createCounter = function (init) {
  let cur = init
  return {
    increment: () => ++cur,
    decrement: () => --cur,
    reset: () => (cur = init),
  }
}
```

## `createCounter` 函数内部

1. **初始化阶段**：当你调用 `createCounter(init)`，JavaScript 引擎首先在内部为这个函数调用创建一个新的执行环境。这个执行环境包含了一个名为 `init` 的参数，它的值是你传递给 `createCounter` 的值。
2. **创建 `cur` 变量**：在这个执行环境中，`cur` 变量被创建并初始化为 `init` 的值。这时，`cur` 和 `init` 都存在于 `createCounter` 的局部作用域中。
3. **返回对象**：`createCounter` 函数返回一个包含三个方法（`increment`、`decrement`、`reset`）的对象。每个方法都是一个函数，这些函数在定义时捕获（闭合）了它们的词法作用域，这意味着它们记住了 `cur` 和 `init` 的值和它们所在的环境。

## 如何实现闭包

- **闭包的形成**：当 `createCounter` 执行完毕并返回那个对象之后，按照常规的理解，`createCounter` 的局部变量（`cur` 和 `init`）应该随着函数执行完毕而被销毁。然而，由于返回的对象中的方法还在引用 `cur` 和 `init`，这些变量并不会被销毁。相反，它们会一直存在，以便这些方法在将来被调用时可以使用。这就是闭包的核心特性：**函数记住并访问其创建时的环境**。
- **方法的行为**：
  - `increment`和 `decrement` 方法通过修改 `cur` 变量的值来工作，它们每次被调用时都会增加或减少 `cur` 的值。
  - **`reset`** 方法则将 `cur` 的值重置为 `init` 的值，无论 `init` 在 `createCounter` 调用时是什么值，`reset` 方法都能通过闭包访问并使用这个初始值。

## Thanks

- [2665. 计数器 II - 力扣](https://leetcode.cn/problems/counter-ii/solutions/)
